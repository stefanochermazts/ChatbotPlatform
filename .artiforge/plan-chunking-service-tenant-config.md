# 🔧 Development Plan: Fix ChunkingService Tenant Configuration

**Generated by**: Artiforge  
**Date**: 2025-10-15  
**Estimated Duration**: 3-4.5 hours  
**Priority**: 🔴 CRITICAL  

---

## Task Overview

**Goal**: Make ChunkingService tenant-configurable to allow per-tenant optimization of document chunking.

**Current Problem**:
- ChunkingService reads `config('rag.chunk_max_chars')` directly, bypassing tenant-specific configuration
- All tenants forced to use same chunking parameters from `.env`
- Admin UI cannot control chunking per tenant
- Performance tuning impossible without code changes

**Expected Outcome**:
- Chunking parameters fully tenant-configurable via TenantRagConfigService
- Admin can tune chunking per tenant without code changes
- Tenant with long PDFs can use 3000 char chunks, tenant with short FAQs can use 1000 chars
- Consistent with other RAG parameters

---

## Implementation Plan (9 Steps)

### Step 1: Fix config/rag.php Naming Inconsistency ⏱️ 15min

**Action**: Correct configuration keys in `config/rag.php` and align them with naming used throughout codebase.

**Reasoning**: Current file has naming mismatch (`chunk.max_chars` vs `chunk_max_chars`). This prevents `TenantRagConfigService` from retrieving correct values and forces `ChunkingService` to fall back to global `config()` calls.

**Implementation**:
1. Open `backend/config/rag.php`
2. Rename keys to `'chunk_max_chars'` and `'chunk_overlap_chars'` (snake_case)
3. Keep original values as defaults:
   ```php
   return [
       // ...
       'chunk_max_chars'    => env('RAG_CHUNK_MAX_CHARS', 2000),
       'chunk_overlap_chars'=> env('RAG_CHUNK_OVERLAP_CHARS', 200),
       // ...
   ];
   ```
4. Run `php artisan config:clear`
5. Add comment explaining naming convention

**Error Handling**:
- Verify `config('rag.chunk_max_chars')` returns expected value via `php artisan tinker`

**Testing**:
- Execute `php artisan tinker` and verify config keys exist
- Add Pest test in `tests/Unit/Config/RagConfigTest.php` asserting keys exist and are integers

---

### Step 2: Update TenantRagConfigService::getChunkingConfig() ⏱️ 20min

**Action**: Update `TenantRagConfigService::getChunkingConfig()` to use corrected config keys.

**Reasoning**: This service is single source of truth for tenant-specific RAG parameters.

**Implementation**:
```php
public function getChunkingConfig(int $tenantId): array
{
    $tenantConfig = $this->getTenantConfig($tenantId);
    return [
        'max_chars'   => $tenantConfig['chunk_max_chars'] ?? config('rag.chunk_max_chars'),
        'overlap_chars'=> $tenantConfig['chunk_overlap_chars'] ?? config('rag.chunk_overlap_chars'),
    ];
}
```

**Error Handling**:
- Guard against non-array tenant config
- Log warning if tenant config not found

**Testing**:
- Unit test with mocked tenant repository:
  - Full config → assert values match
  - Partial config → assert missing key falls back to global
  - No config → assert both fall back to global

---

### Step 3: Inject TenantRagConfigService into ChunkingService ⏱️ 45min

**Action**: Inject `TenantRagConfigService` into `ChunkingService` and modify API to accept tenant identifier.

**Reasoning**: Service currently uses `config()` directly, bypassing tenant logic.

**Implementation**:
1. Add private property: `private TenantRagConfigService $tenantConfigService;`
2. Update constructor:
   ```php
   public function __construct(TenantRagConfigService $tenantConfigService)
   {
       $this->tenantConfigService = $tenantConfigService;
   }
   ```
3. Change `chunk()` signature:
   ```php
   public function chunk(string $content, int $tenantId, ?int $maxChars = null, ?int $overlap = null): array
   ```
4. Inside method, fetch tenant config:
   ```php
   $config = $this->tenantConfigService->getChunkingConfig($tenantId);
   $maxChars   = $maxChars ?? $config['max_chars'];
   $overlap    = $overlap ?? $config['overlap_chars'];
   ```

**Error Handling**:
- Validate `$tenantId` is positive integer
- If config service fails, log and fall back to global config

**Testing**:
- Update unit tests to mock `TenantRagConfigService`
- Add test where `$maxChars` and `$overlap` override tenant config
- Run `php artisan test` and verify 100% coverage

---

### Step 4: Refactor determineOptimalChunkSize() ⏱️ 15min

**Action**: Refactor `determineOptimalChunkSize()` to accept `$tenantId` and use tenant-specific configuration.

**Reasoning**: Helper method currently pulls values from global config.

**Implementation**:
```php
private function determineOptimalChunkSize(string $content, int $tenantId): int
{
    $config = $this->tenantConfigService->getChunkingConfig($tenantId);
    $baseChunkSize = $config['max_chars'];
    
    if (strlen($content) < 10000) {
        return $baseChunkSize;
    }
    
    return min(3000, $baseChunkSize + 500);
}
```

**Error Handling**:
- Guard against empty `$content`
- Handle zero-length gracefully

**Testing**:
- Extend `ChunkingServiceTest` to verify small `max_chars` respected
- Test edge case where `$content` length < `max_chars`

---

### Step 5: Update All Callers ⏱️ 60min

**Action**: Update all callers of `ChunkingService::chunk()` to provide tenant identifier.

**Reasoning**: Without `$tenantId`, service falls back to global defaults.

**Implementation**:

1. **DocumentIngestionService** (`backend/app/Services/Ingestion/DocumentIngestionService.php`):
   ```php
   $chunks = $this->chunkingService->chunk($content, $document->tenant_id);
   ```

2. **IngestUploadedDocumentJob** (`backend/app/Jobs/IngestUploadedDocumentJob.php`):
   ```php
   $tenantId = $this->document->tenant_id;
   $chunks = $chunkingService->chunk($content, $tenantId);
   ```

3. **WebScraperService** (`backend/app/Services/Scraper/WebScraperService.php`):
   ```php
   $tenantId = $config->tenant_id; // ScraperConfig has tenant_id
   $chunks = $chunkingService->chunk($markdown, $tenantId);
   ```

**Error Handling**:
- If caller cannot obtain tenant ID, log error and default to global config

**Testing**:
- Add unit tests for each caller
- Mock `Document` with `tenant_id = 1` and assert `ChunkingService->chunk()` receives `1`
- Run existing feature test suite

---

### Step 6: Cache Management ⏱️ 5min

**Action**: Invalidate and rebuild configuration cache.

**Reasoning**: Laravel caches config values; stale keys would cause runtime errors.

**Implementation**:
```bash
php artisan config:clear
php artisan cache:clear
php artisan config:cache
```

**Error Handling**:
- If `config:cache` fails, CI run will stop

**Testing**:
- Run `php artisan tinker` to verify `config('rag.chunk_max_chars')` reflects updated keys
- Verify unit/feature tests pass with cached config

---

### Step 7: Write Comprehensive Tests ⏱️ 60min

**Action**: Write comprehensive tests covering tenant-specific chunking behavior.

**Reasoning**: Tests guarantee multitenant logic works now and after future changes.

**Implementation**:

**Unit Tests** (`tests/Unit/Services/Ingestion/ChunkingServiceTest.php`):
- Mock `TenantRagConfigService` returning different configs for tenant IDs 1 and 2
- Assert `chunk()` produces arrays respecting `max_chars` and `overlap_chars`

**Feature Test** (`tests/Feature/TenantChunkingTest.php`):
- Create two tenant records with distinct RAG configs (3000/200 vs 1000/100)
- Upload/scrape sample document (~5000 chars) for each tenant
- Assert number of chunks and lengths differ per tenant config
- Verify database chunks match expectations

**Error Handling**:
- If test suite fails due to missing factories, create them
- Use `Bus::fake()` for async jobs

**Testing**:
- Run `php artisan test --filter TenantChunkingTest`
- Run full test suite to confirm no regressions

---

### Step 8: Update Documentation ⏱️ 20min

**Action**: Update documentation to reflect new tenant-configurable chunking flow.

**Reasoning**: Developers and admins need guidance on where to set chunk sizes.

**Implementation**:
- Edit `README.md` or relevant docs section
- Add subsection "Tenant-specific RAG chunking configuration"
- Explain env variables `RAG_CHUNK_MAX_CHARS` and `RAG_CHUNK_OVERLAP_CHARS` as global defaults
- Show how admins override per tenant via UI at `/admin/tenants/{id}/rag-config`
- Mention changes require re-ingestion of documents
- Update inline PHPDoc for modified methods

**Testing**:
- Manually review rendered docs for clarity

---

### Step 9: Final Quality Check ⏱️ 20min

**Action**: Perform final code quality check and run complete test suite.

**Reasoning**: Guarantee all changes comply with project code rules.

**Implementation**:
- Run `phpstan analyse` to catch type errors
- Execute `pint` for PSR-12 compliance
- Run `php artisan test` for whole suite
- Verify CI pipeline passes

**Error Handling**:
- Clean up unused imports
- Debug failing tests and adjust code/expectations

**Testing**:
- Full test run: `php artisan test`
- Ensure coverage >80% for modified services

---

## Time Estimates

| Step | Task | Duration |
|------|------|----------|
| 1 | Fix config/rag.php naming | 15 min |
| 2 | Update TenantRagConfigService | 20 min |
| 3 | Inject service + refactor chunk() | 45 min |
| 4 | Refactor determineOptimalChunkSize() | 15 min |
| 5 | Update all callers (3 files) | 60 min |
| 6 | Cache management | 5 min |
| 7 | Write comprehensive tests | 60 min |
| 8 | Update documentation | 20 min |
| 9 | Final quality check | 20 min |
| **TOTAL** | | **4 hours** |

---

## Success Criteria

✅ ChunkingService accepts `$tenantId` parameter  
✅ All callers pass correct tenant ID  
✅ Tenant config overrides global config  
✅ Tests verify different tenants get different chunk sizes  
✅ Admin UI can control chunking per tenant  
✅ Documentation updated  
✅ All tests pass  
✅ PSR-12 compliant  

---

## Risk Mitigation

| Risk | Severity | Mitigation |
|------|----------|------------|
| Existing documents have old chunk sizes | Medium | Add migration guide for re-ingestion |
| Config cache serves stale values | Low | TenantRagConfigService has 5-min TTL + Cache::forget on update |
| Breaking change to public API | High | Keep backward compatibility via optional params |

---

## Rollback Plan

If issues arise:
1. Revert commits in reverse order
2. Run `php artisan config:clear`
3. Re-deploy previous stable version
4. Document issues for future retry

---

**Plan Ready for Execution** 🚀

Follow steps 1-9 in order, requesting confirmation before each step.

